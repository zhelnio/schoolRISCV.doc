---
marp: true
size: 16:9
---

<style>
img[alt~="center"] {
  display: block;
  margin: 0 auto;
}
</style>

# SchoolRISCV

https://github.com/zhelnio/schoolRISCV

Stanislav Zhelnio, 2020

<!-- Добрый день! Данная лекция является введением в микроархитектуру процессорных систем. И эту тему мы рассмотрим на примере проекта schoolRISCV. Адрес, по которому доступны исходные коды проекта, а также материалы лекции приведен на первом слайде -->

---

<!-- paginate: true -->

## Благодарности

- David Harris & Sarah Harris
- Юрий Панчул
- Александр Романов
- IVA Technologies

<!-- Что такое schoolRISCV это самое простое процессорное ядро, которое только можно придумать и оно бы не появилось на свет без легендарного учебника Дэвида Харрис и Сары Харрис "Цифровая схемотехника и архитектура компьютера. Раньше проект назывался schoolMIPS и идея создать его принадлежит Юрию Панчулу. Очень активное участие в разработке микроархитектуры первой версии ядра принял Александр Романов. А его студенты портировали и запустили его на множестве отладочных плат. Также будет правильным упомянуть компанию IVA Technologies, работником которой я являюсь, за возможность работать над этим open source проектом в рабочее время. Так, в частности, подготовлена данная презентация -->

---

## Что такое schoolRISCV

- простое процессорное ядро для практического преподавания школьникам основ цифровой схемотехники
- написано на языке Verilog
- реализует подмножество архитектуры RISCV
- вырос из аналогичного проекта schoolMIPS

<!-- Итак, что такое schoolRISCV - это самое простое процессорное ядро, которое можно только придумать. И оно создавалось изначально для того, чтобы можно было объяснить школьникам, людям без профильного образования, как работает процессор. При этом оно не является "игрушечным": - написано на "взрослом" языке описания аппаратуры Verilog; реализует подмножество архитектуры RISCV - т.е. на нем может быть запущена программа, скомпилированная "взрослым" компилятором. Пусть и с некоторыми нюансами навроде того, что поддерживаются не все инструкции RISCV, а только их часть - подмножество -->

---

## Микроархитектура

![bg right 45%](img/ma.png)

- аппаратная реализация архитектуры в виде схемы

- возможны разные реализации одной архитектуры:
    - однотактная
    - многотактная
    - конвейерная

<!-- Что такое микроархитектура? Микроархитектура это аппаратная реализация архитектуры в виде некой цифровой схемы. В чем принципиальная разница между микроархитектурой и архитектурой вычислительной системы? Для программистов архитектура выглядит как набор инструкций и регистров, которые доступны внутри проецссора. На архитектуру вычислительной системы можно смотреть как на договор или соглашение между разработчиками процессоров и программистами, которому следуют обе стороны. Следование этому договору позволяет писать программы, которые могут выполняться на процессорах, имеющих разную реализацию - разную микроархитектуру.
Т.е. процессоры могут быть спроектированы совершенно по разному и разными командами инженеров. Например, этом один процессор может быть разработан с упором на энергопотребление, а другой с целью получить максимальную производительность. Но если при этом они соответствуют требованиям архитектуры, то запущенная на них одна и та же программа будет выдавать один и тот же результат.
В самом простейшем виде мы можем реализовать одну и ту же архитектуру в виде процессора с однотактной, многотактной или конвейерной микроархитектурой. В первом случае каждая инструкция выполняется ровно один такт. Во втором - несколько тактов. И в последнем - процессор одновременно выполняет несколько инструкций, каждая из которых находится на своей стадии выполнения.
Все современные процессоры - конвейерные.
При этом однотактный процессор очень хорошо рассматривать для обучения. -->

---

## Особенности schoolRISCV

- однотактная реализация
- нет памяти данных
- словная адресация памяти команд
- 9 инструкций: **add**, **or**, **srl**, **sltu**, **sub**, **addi**, **lui**, **beq**, **bne**

...и этого уже достаточно, чтобы посчитать квадратный корень!

<!-- В чем особенности schoolRISCV - это однотактная реализация архитектуры RISC-V, максимально похожая на однотактный процессор архитектуры MIPS, описанный на страницах книги Цифровая схемотехники и архитектура компьютера. При этом он еще больше упрощен по сравнению с описанным в книге: в частности у него нет памяти данных. Словная адресация памяти команд - что это такое мы поговорим в дальнейшем. И всего 9 инструкций. При этом этих 9 инструкций достаточно, чтобы посчитать, например, квадратный корень. Т.е. не смотря на то, что этот процессор можно спроектировать за 1 час и реализовать еще за 1 час с ноля, на нем программно можно выполнять вычисления, которые далеко не каждый человек может выполнить на листке бумаги. -->

---

## Последовательность проектирования

- тракт данных
  Data Path

- устройство управления
  Control Unit

<!-- Как мы будем его проектировать? Мы начнем с тракта данных - это тем цепи и устройства, через которые непосредственно ходят обрабатываемые нами данные. После чего спроектируем устройство управления - блок, который обеспечивает управление коммутацией между устройствами тракта данных, и устанавливает режимы работы этих устройств в зависимости от того, какая инструкция сейчас выполняется. -->

---

## Спецификация RISC-V

![h:500 center](img/riscv_spec.png)

https://riscv.org/specifications/

<!-- Чем мы при этом будем руководствоваться? Мы будем руководствоваться спецификацией архитектуры RISC-V, которую можно загрузить по адресу, приведенному на слайде. Эта спецификация как раз является договором между разработчиками аппаратных средств и программных средств.
Что мы можем про нее сказать? Во-первых это живой документ, в который периодически вносятся изменения. Мы, в частности, рассматриваем версию от декабря 2019 года. И нас интересует только первый том спецификации, в котором описаны непривилегированные инструкции. Те инструкции, которые доступны программисту, когда он пишет обычную прикладную программу. И мы не рассматриваем привилигерованные инструкции - те, с помощью которых можно управлять режимами работы процессора, что необходимо, например при разработке ядра операционной системы. Это мы оставим за кадром. Если кому-то из вас интересно, что это за инструкции, то в будущем вы можете скачать соответствующую спецификацию и ознакомиться с ними. -->

---

## Наборы команд RISC-V: спецификация

![h:500 center](img/riscv_is.png)

<!-- Еще из интересного про RISC-V. Спецификация разделена на разделы, описывающие наборы команд. Есть 4 базовых набора команд, один из которых обязательно должен быть реализован в RISC-V процессоре. И есть наборы расширений, реализация которых не является обязательной, но при этом повышает возможности процессора. К примеру, набор M - это инструкции аппаратного умножения и деления. А набор F - это инструкции для работы с числами с плавающей точкой.
Мы будем рассматривать команды из базового набора RV32I - это набор инструкций для работы с 32-битными целыми числами. Вот часть из этих инструкций мы реализуем в своем процессоре -->

---

## Архитектурное состояние: спецификация

![w:1080 center](img/riscv_pm.png)

<!-- Начнем мы с того, что посмотрим на процессор, как на конечный автомат. Конечный автомат - это система, следующее состояние которой зависит от текущего состояния и от того, какие сигналы находятся у нее на входах. При этом выходные сигналы зависят либо только от текущего состояния, либо еще и от входных сигналов. Вот это сотояние конечного автомата применительно к процессору называется Архитектурным состоянием. И, в частности, в спецификации оно описано следующим образом. Что оно включает в себя 32 регистра общего назначения, широной 32 бита каждый. При этом самый первый (нулевой) регистр при чтении всегда возвращает ноль.
И также есть регистр под названием program counter, который содержит адрес текущей выполняемой инструкции -->

---

## Архитектурное состояние

![h:600 center](png/cpu_00.png)

<!-- Изобразим элементы архитектурного состояния на схеме. Первым идет program counter. Это обычный 32-битный регистр. У него есть вход, на который подается его следующее значение, и выход, с которого можно считать текущее. Следующие значение превращается в текущее по фронту тактового сигнала.
Теперь рассмотрим блок регистров общего назначения. У него есть 3 порта. Два порта чтения, и один порт записи. Первый порт чтения - это вход A1 и выход RD1. На вход мы подаем номер регистра, данные которого хотим считать. На выходе мы получаем данные этого регистра. Чтение при этом асинхронное - данные доступны в том же такте. Работа второго порта чтения, который A2 - RD2 абсолютно аналогично. С портом записи все немного сложнее: на вход A3 подается номер регистра, в который необходимо сохранить данные, на WD3 - сами записываемые данные. А на вход WE3 - сигнал разрешения записи. И в этом случае данные будут записаны по фронту тактового сигнала. После чего станут доступны для чтения начиная со следующего такта.
Чуть позже мы рассмотрим реализацию каждого из этих блоков на Verilog.
Также у нас есть память команд, в которой хранится наша программа. У нее есть вход адреса текуй инструкции, и выход данных. Чтение также асинхронное - данные доступны в этом же такте.
Также есть память данных, которая условно показана серым цветом, т.к. в schoolRISCV она отсуствует, т.е. мы считаем, что ее у нас нет.
Забегая вперед, после завершения этой лекции для вас не составит труда добавить ее в процессор самостоятельно, либо подсмотрев, как это делается для MIPS процессора на страницах Цифвровой схемотехники и архитектуры компьютера. -->

---

## ADDI: выборка инструкции

![h:600 center](png/cpu_01.png)

<!-- Мы будем проектировать процессор следующим образом: начнем с выборки инструкции из памяти, и постепенно будем наращивать тракт данных блоками, которые необходимы, чтобы эту инструкцию в процессоре реализовать. Итак, PC содержит адрес инструкции. И у нас есть память команд, которая содержит программу, состоящую из 32-битных инструкций. Нам необходимо выбрать из памяти команд инструкцию, которая лежит по адресу. Но есть один нюанс: PC содержит адрес первого байта инструкции в памяти. А память инструкций у нас хранит 32-битные слова, каждое из которых состоит из 4 байт, или, выражаясь иначе, имеет словную адресацию. Поэтому для того, чтобы выполнить корректное чтение, нам необходимо разделить текущий адрес на 4, либо выполнить сдвиг адреса на 2 бита вправо. Что мы и делаем. Мы добавляем схему сдвига вправо, вход которой подключаем на выход PC, а выход - на вход адреса памяти команд. После этого на выходе памяти RD мы можем считать текущую выбранную инстркуцию.
И нам необходимо как-то ее интерпретировать. В соответствии с какими правилами мы будем эту инструкцию интерпретировать. -->

---

## ADDI: спецификация

![w:1080 center](img/riscv_addi.png)
![w:1080 center](img/riscv_immi.png)

<!-- Для этого давайте посмотрим в спецификацию. Пусть текущая выбранная инструкция - это инструкция сложения числа, которое хранится в регистре общего назначения, с константой. Эта команда, которая называется ADDI - add immediate. Описание этой инструкции из спецификации привидено на экране.
Я рекомендую вам открыть спецификацию и найти описание этой инструкции в документе. Это может немного упростить вам дальнейшую работу, т.к потом, когда вы получите задание самостоятельно реализовать ту или иную инструкцию и добавить ее поддержку в schoolRISCV, вам будет проще ориентироваться в документе.
Итак, что мы можем сказать про инструкцию ADDI:
- мы можем идентифицировать эту инструкцию, т.е. отличить ее от других инструкций с помощью полей opcode и funct3 - это поля, которые имеют свое уникальное значение.
- для того, чтобы выполнить операцию ADDI нам необходимо взять число из регистра с номером rs1, прибавить к нему констранту, закодированную в поле Immediate, и сохранить результат в регистре с номером rd
- поле Immediate имеет ширину 12 бит, и тот способ, которым мы преваращем ее в 32-битное число также приведен в спецификации. Мы видим, что  младшие 11 разрядов константы (с 0 по 10) используются как есть, а вот старший бит копируюется во все биты с 11 по 31. По факту так производится расширение знака для чисел в дополнительном коде. 
Хорошо, теперь мы понимаем, что нам необходимо получить -->

---

## ADDI: считывание операнда из регистрового файла

![h:600 center](png/cpu_02.png)

<!-- Начнем с регистра rs1, в котором хранится один из операндов инструкции. Номер этого регистра содержится в поле с 15 по 19 биты команды. Для того, чтобы считать значение из регистра с этим номером мы соединяем эти биты инструкции с адресным входом A1 первого порта чтения регистрового файла. Так на выходе RD1 мы получили число, которое хранится регистре c номером RS1 -->

---

## ADDI: декодирование константы из тела инструкции

![h:600 center](png/cpu_03.png)

<!-- Продолжаем. Один операнд у нас уже есть, получим значение второго операнда операции сложения. Для этого нам необходимо декодировать поле Immediate и превратить его в 32-битную константу. Сделаем это в точном соответсвии со спецификацией: младшие 11 бит используем как есть, срашим битом заполняем все встаршие разряды 32-битного числа. И делать это будем в новом блоке, который назовем Декодером Инструкций, куда поместим всю комбинационную логику с этим связанную -->

---

## ADDI: вычисление результата арифметической операции

![h:600 center](png/cpu_04.png)

<!-- Итак, у нас есть два операнда: одно число мы получили из регистра, второе декодировали из тела инструкции. Теперь эти числа необходимо сложить. Делать это мы будем с помощью специального блока, который называется Арифметико-логическое устройство, или Arifmetic Logic Unit (ALU). Это комбинационная схема, внуртри которой вычисляются все арифметические и логические операции над данными. И у которой есть:
- два входа для данных (srcA и scrB);
- управляющий вход aluControl, с помощью которого мы задаем режим работы АЛУ - ту операцию, которую мы ходим выполнить над входными данными. Это может быть сложение, как в нашем текущем случае, или вычитание, сдвиг и т.д. Значение сигнала aluControl в дальнейшем будет задаваться с помощью устройства управления - блока Control Unit;
- также у АЛУ есть выходной порт result, с которого можно считать результат вычислений 
На один вход мы подаем данные, которые мы извлекли из регистра. На второй порт мы подаем константу, которую мы сформировали из соответствующего поля обрабатываемой инструкции. Устройство управления, это мы рассмотрим позже, на основе полей opcode и func3 формируем соответствующий сигнал aluControl. И в результате на выходе АЛУ мы получаем результат сложения данных, извлеченных из регистра rs1 и константы.
-->

---

## ADDI: декодирование регистра назначения

![h:600 center](png/cpu_05.png)

<!-- Мы получили результат сложения операндов и теперь нам необходимо его сохранить в регистровый файл. Номер регистра, в который нам необходимо выполнит сохранение, задается в поле инструкции RD. Уже привычным нам способом подключаем биты инструкции с 7 по 11 к адресному входу порта записи A3 регистрового файла. -->

---

## ADDI: запись результата в регистр назначения

![h:600 center](png/cpu_06.png)

<!-- Теперь нам необходимо передать записываемые данные на вход порта записи регистрового файла. Делаем это, соединяя выход АЛУ - сигнал aluResult со входом регистрового файла WD3. Помимо этого устройство управление обеспеечивает подачу сигнала regWrite на вход разрешения записи WE3. Теперь, когда все эти условия выполнены, то когда наступит фронт тактового сигнала, данные будут записаны в регистровый файл. Важный момент: все, что мы обсуждаем, начиная с момента выборки инструкции из памяти данных, происходит в течении одного и того же такта. -->

---

## ADDI: вычисление адреса следующей инструкции

![h:600 center](png/cpu_07.png)

<!-- Мы вычислили результат сложения числа и константы и подготовили данные к записи в регистровый файл. Для того, чтобы на следующем такте перейти к следующей инструкции, нам необходимо вычислить ее адрес. Мы помним, что одна инструкция занимает 4 байта, поэтому добавляем в схему сумматор, который прибавит к текущему значению PC число 4, и подключим его выход на вход регистра PC  -->

---

## ADDI: итоговая схема

![h:600 center](png/cpu_08.png)

<!-- В итоге процессор, который умеет выполнять одну единственную команду целочисленного сложения регистрового операнда и константы выглядит следующим образом. Давайте еще раз повторим тот путь, который проходят обрабатываемые данные:
- мы производим выборку инструкции по текущему адресу PC;
- декодируем инструкцию и получаем из нее номер регистра, в котором хранится первый операнд, считываем информацию из регистра с этим номером, подаем ее на вход АЛУ;
- из декодированной инструкции получаем значение константы, которые подаем на второй вход АЛУ;
- по коду инструкции определяем, какую именно операцию должен выполнить код АЛУ и устанавливаем ему соответствующий режим работы;
- вычисляем результат операции и подаем его на порт записи регистрового файла, разрешаем запись в регистровый файл;
- из декодированной инструкции получаем номер регистра, в который необходимо сохранить результат;
- вычисляем адрес следующей команды;
После всего перечисленного, как только наступит фронт тактового сигнала в регистровый файл в регистр с номером RD будет записан результат выполнения операции. А в регистр PC - адрес следующей команды 
Теперь у нас есть процессор, который умеет выполнять одну инструкцию. Давайте добавим еще несколько. При этом для каждоый из добавляемых инструкций мы будем вносить изменения в уже существующую схему.
-->

---

## ADD: спецификация

![w:1080 center](img/riscv_add.png)

<!-- Добавим в процессор поддержку команды ADD - инструкции целочисленного сложения двух регистровых операндов. От ранее рассмотренной ADDI она отличается тем, что оба операнда хранятся в регистровом файле. Нам необходимо сложить числа из регистров rs1 и rs2 и сохранить результат операции в регистр rd. При этом от других инструкций ее отличают уникальное сочетаний значений полей opcode, funct3 и funct7 -->

---

## ADD: выборка операнда rs1

![h:600 center](png/cpu_09.png)

<!-- Выборка инструкции из памяти, ее декодирование и выброрка операнда RS1 и его подача на вход ALU srcA выполняеются с помощью уже существующей схемы, и какие-либо модификации в нее на данном этапе вносить нет необходимостии -->

---

## ADD: выборка операнда rs2

![h:600 center](png/cpu_10.png)

<!-- Выборку из регистрового файла операнда rs2 произведем аналогичным образом: подключим на вход регистрового файла A2 значение числа, которое хранится в поле rs2 - биты инструкции 20-24. После этого на выходе RD2 появится значение, которое хранится в соответствующем регистре. И здесь возникает интересная ситуация: нам необходимо подать значение с порта регистрового файла RD2 на вход АЛУ srcB, но на этот вход уже подключена константа. -->

---

## ADD: передача второго операнда в АЛУ

![h:600 center](png/cpu_11.png)

<!-- Ничего страшного. Добавляем в наш тракт данных мультиплексор, с помощью которого мы будем переключать вход АЛУ между источниками данных: регистровым файлом или декодированной константой. Управляться этот мультиплексор будет сигналом aluSrc, значение которого должно задаваться Устройством управления в зависимости от обрабатываемой на текущем такте команды -->

---

## ADD: итоговая схема

![h:600 center](png/cpu_12.png)

<!-- Итоговая схема процессора, который умеет выполнять две команды: ADDI и ADD приведена на слайде. Я прошу вас потратить некоторое время и самостоятельно проследить путь всех сигналов, с помощью которых обеспечивается вычисление инструкции ADD c момента считывания инструкции из памяти, и заканчивая моментом сохранения результата и перехода к следующей инструкции. -->

---

## LUI: спецификация

![w:1080 center](img/riscv_lui.png)
...
![w:1080 center](img/riscv_immu.png)

<!-- Следующей добавляемой инструкцией будет загрузка константы в регистр. Инструкция LUI - load upper immediate. Что мы можем про нее сказать? Во-первых эта инструкция не предполагает совершения каких-либо арифметических операций. Во-вторых формат декодируемой константы отличается от того, который мы рассматривали ранее. В этом случае поле Immediate уже шириной 20 бит, которые используются в качестве старших разрядов получаемой константы, а младшие при этом заполняются нулями. Это значение должно быть помещено в регистр RD. При этом отличаем эту инструкцию от других мы с помощью уникального значения поля opcode. -->

---

## LUI: декодирование и передача константы

![h:600 center](png/cpu_13.png)

<!-- Давайте добавим ее. Первым делом мы декодируем константу, получив сигнал immU на выходе декодера инструкции. И тут мы видим, что ситуация опять повторяется: нам необходимо подать константу на вход записываемых данных регистрового файла. А туда уже подключен выход АЛУ. Что мы делаем? Как и в прошлый раз мы добавляем мультиплексор. И сигнал wdSrc будет управлять этим мультиплексором и подключать вход записываемых данных регистрового файла либо к выходу АЛУ, либо к константе с декодера инструкций. Поддержка команды добавлена. -->

---

## BEQ: спецификация

![w:1080 center](img/riscv_bne.png)

<!-- Все рассмотренные выше команды предполагают поочередное исполнение, а это очень сильно ограничивает нас в возможнстях программирования под наш процессор. Рассмотрим операции ветвления, с помощью которых мы сможем выполнять условные переходы и реализовывать циклы.
Первой из рассматриваемых команд будет BEQ - branch on equal. Смысл которой заключается в том, чтобы в случае, если значения, которые хранятся в регистрах rs1 и rs2, совпадают, то к значению PC прибавляется значение константы, каким-то определнным образом закодированной в теле инструкции. Эта константа хранится в дополнительном коде, т.е. может быть как положительной, так и отрицательной, что позволяет совершать переходы как вперед, так и назад.  -->

---

## BEQ: вычисление адреса условного перехода

![h:600 center](png/cpu_14.png)

<!-- Вычислим адрес, по которому будет выполняться условный переход, если в этом будет необходимость. Для этого сперва декодируем константу immB. Пусть нас не смущает, что биты константы идут в несколько непривычном порядке и не подряд. Мы реализуем наш процессор в соответствии со спецификацией, и там определен такой порядок. Это требование архитектуры.
После того, как на выходе декодера инструкций мы получили инкремент перехода immB, добавим в схему еще один сумматор, с помощью которого будем вычислять новое значение PC на случай, если нам необходимо выполнить условный переход - сигнал pcBranch. -->

---

## BEQ: выбор адреса

![h:600 center](png/cpu_15.png)

<!-- Для того, чтобы иметь возможность выбрать между переходом к следующей по порядку инструкции или условным переходом на адрес pcBranch, добавим мультиплексор pcSrc. И теперь давайте подумаем, каким образом должно задаваться его значение. Условный переход должен быть выполнен, если значения в регистрах rs1 и rs2 совпадают. Существующая схема процессора позволяет выбрать значения из этих регистров и подать их на вход АЛУ. Каким образом мы можем сравнить два числа? Ответ на этот вопрос: операция вычитания. Пусть наш АЛУ умеет делать вычитание. И если вычитая одно число из другого мы получаем на выходе ноль, значит числа равны. -->

---

## BEQ: определение необходимости перехода

![h:600 center](png/cpu_16.png)

<!-- Реализуем этот подход, добавив на выход АЛУ сигнал aluZero, который будет сигнализировать нам о ситуации, когда результат выполнения арифметической операции равен нулю. Помимо этого добавим логический элемент "И" и управляющий сигнал branch: пусть для операций ветвления branch будет равен 1, и в этом случае aluZero сможет влиять на значение pcSrc. А для обычных арифметических или логических операций выполняет ветвление нет никакой необходимости, поэтому branch должен быть равено 0, и вход регистра PC будет подключен к сигналу pcPlus4 - т.е. будет выполняться переход к следующей комнаде. -->

---

## BEQ: итоговая схема

![h:600 center](png/cpu_17.png)

<!-- Итоговая схема приведена на экране. Пожалуйста, потратте некоторое время и воспроизведите про себя, каким образом происходит операция ветвления. В каждом из случаев: когда условный переход выполняется, и когда он не выполняется. -->

---

## BNE: BEQ наоборот

![h:600 center](png/cpu_18.png)

<!-- Рассмотрим еще одну операцию ветвления: BNE, Branch-on-non-equal. Она очень похожа на рассмотренную ранее BEQ, за исключением того, что условный переход выполняется, когда значения в регистрах rs1 и rs2 не равны. И не выполняется, когда они равны. Т.е. все то же самое, что и ранее, но наоборот. Давайте попробуем ее реализовать. -->

---

## BNE: новая цепь управления

![h:600 center](png/cpu_19.png)

<!-- Для этого добавим в управляющие цепи схему сравнения на базе элемента XOR с инвертированным выходом. Вспомним, что из себя представляет XOR, который также называют "Исключающее-ИЛИ". Если значения на входах XOR отличаются, на его выходе - единица. Если совпадают (два нуля, или две единицы) - на его выходе ноль. Если мы инвертируем его выход, то получаем схему сравнения.
На один из входов схемы сравнения мы подключим сигнал aluZero с выхода АЛУ. А второй вход назовем управляющим сигналом condZero и будем подавать на него 1 для команды BEQ, или 0 для инструкции BNE. Это позволит нам принимать решение о необходимости условного перехода в зависимости от того, какую из команд условного перехода мы в данный момент обрабатываем.
На этом реализацию инструкции BNE можно считать завершенной-->

---

## Устройство управления

![h:600 center](png/cpu_20.png)

<!-- Если внимательно посмотреть на полученную схему, то становится понятно, что вентили AND и XOR, по сути, задают значения упрвляющийх сигналов. Давайте поместим их внутрь Устройства управления и подключим к нему остальные управляющие сигналы. На основании чего устройство управления должно формировать значения этих управляющих сигналов? -->

---

## Декодирование типа инструкции

![h:600 center](png/cpu_21.png)

<!-- Устройство управления задает значения выходных управляющих сигналов на основе декодирования инструкции. А именно: значений полей opcode, funct3 и funct7. В нашем случае, и в исходных кодах schoolRISCV эти сигналы называются cmdOp, cmdF3 и cmdF7. Подключим их с выхода декодира инструкций на вход устройства управления. -->

---

## Итоговая схема процессора

![h:600 center](png/cpu_22.png)

<!-- На этом проектирование тракта данных можно считать завершенным. Итоговая схема процессора приведена на слайде.
В schoolRISCV реализовано еще несколько инструкций, которые мы не стали расматривать выше, т.к. они могут быть добавлены без внесения каких-то существенных изменений в тракт данных. Так, например, операция регистрового вычитания в части прохождения сигналов ничем не отличается от операции регистрового сложения, кроме управляющего сигнала aluControl, который должен задать режим работы АЛУ, соответствующий именно вычитанию, а не сложению.
Первая стадия проектирования процессора завершена. Теперь рассмотрим получшийся тракт данных, перечислим основные блоки, которые входят в его состав и реализуем их на языке Verilog
Итак, в состав тракта данных входят:
    - Счетчик команд _PC_
    - Память инструкций _Instruction Memory_
    - Декодер инструкций _Instruction Decoder_
    - Регистровый файл _Register File_
    - Арифметико-логическое устройство _ALU_
    - Сумматоры адреса _pcPlus4_ и _pcBranch_
    - Мультиплексоры _pcSrc_, _wdSrc_ и _aluSrc_
-->

---

## Состав процессора

- Тракт данных
    - Счетчик команд _PC_
    - Память инструкций _Instruction Memory_
    - Декодер инструкций _Instruction Decoder_
    - Регистровый файл _Register File_
    - Арифметико-логическое устройство _ALU_
    - Сумматоры адреса _pcPlus4_ и _pcBranch_
    - Мультиплексоры _pcSrc_, _wdSrc_ и _aluSrc_
- Устройство управления

<!-- Помимо перечисленных блоков есть еще устройство управления. И мы вернемся к его проектированию после завершения работы над трактом данных  -->

---

## Реализация: PC, сумматоры и мультиплексор адреса

```Verilog
// sm_register.v
module sm_register (
    input                 clk,
    input                 rst,
    input      [ 31 : 0 ] d,
    output reg [ 31 : 0 ] q
);
    always @ (posedge clk or negedge rst)
        if(~rst) q <= 32'b0;
        else     q <= d;
endmodule
```

```Verilog
// sr_cpu.v
    wire [31:0] pc;
    wire [31:0] pcBranch = pc + immB;
    wire [31:0] pcPlus4  = pc + 4;
    wire [31:0] pcNext   = pcSrc ? pcBranch : pcPlus4;
    sm_register r_pc(clk ,rst_n, pcNext, pc);
```
https://github.com/zhelnio/schoolRISCV/tree/00_simple/src

<!-- Перед тем, как мы продолжим, я рекомендую вам открыть исходные коды процессора schoolRISCV и искать в них те фрагменты, которые вы будете видеть на слайдах. Ссылка на github с проектом приведена на слайде. Подобный совет обусловлен тем, что в дальнейшем, когда вы будете самостоятельно добавлять поддержку новой инструкции, это упростит вашу навигацию по исходому коду проекта.  
Итак, регистр program counter выполнен в виде отдельного модуля, представляющего собой обычную последовательностную схему. Регистр с асинхронным сбросом по спаду сигнала rst. При сбросе в регистр записываются нули. И мы это используем: в процессоре schoolRISCV программа начинается с нулевого адреса. Т.е. сразу после сброса процессор начнет выполнять инструкцию, размещенную в самом начале памяти.
Сумматоры адреса pcBranch и pcPlus4 реализованы с помощью непрерывного присваивания и оператора сложения. При синтезе Verilog в цифровую схему эти конструкции будут преобразованы в сумматоры.
Мультиплексор pcNext реализован с помощью т.н. тернарного оператора: если сигнал pcSrc равен 1, значит pcNext будет равен pcBranch, в противном случае - pcPlus4.
-->

---

## Реализация: память инструкций

```Verilog
// sm_rom.v
module sm_rom
#(
    parameter SIZE = 64
)
(
    input  [31:0] a,
    output [31:0] rd
);
    reg [31:0] rom [SIZE - 1:0];
    assign rd = rom [a];

    initial begin
        $readmemh ("program.hex", rom);
    end

endmodule
```

```Verilog
// sm_top.v
sm_rom reset_rom(imAddr, imData);
```

<!-- Память инструкций. То, что вы видите на экране, это так называемая асинхронная память. Т.е. память, доступ к данным внутри которой осуществляется в том же такте, в котором вы выставили адрес на порту адреса. Есть еще синхронная память, когда данные на выходе доступны на следующем такте. Синхронная память может работать на большей частоте, чем асинхронная и на практике используется гораздо чаще. Мы в данном случае вынуждены использовать асинхронную память, т.к. проектируем однотактный процессор, и данные на выходе памяти нам нужны в том же такте.
Для того, чтобы описанная на языке Verilog память была распознана именно как память, необходимо писать код определенным образом. Эта функциональность средств синтеза для ПЛИС называется memory inference и требования к исходному коду приведены в документации Quartus или Vivado. Примеры корректно описанной памяти также доступны в интерфейсе этих программ среди шаблонов кода Templates.
При проектировании микросхем (ASIC) используют готовые топологические блоки памяти.
Конструкция readmemh является встроенной функцией Verilog и предзназначена для инициализации памяти и распознается средствами синтеза. Т.е. наша программа попадает в память инструкций сразу при синтезе. К недостаткам этого решения можно отнести необходимость пересинтезировать процессор каждый раз, когда меняется программа 
-->

---

## Реализация: декодер инструкций (начало)

```Verilog
// sr_cpu.v
module sr_decode
(
    input      [31:0] instr,
    output     [ 6:0] cmdOp,
    output     [ 4:0] rd,
    output     [ 2:0] cmdF3,
    output     [ 4:0] rs1,
    output     [ 4:0] rs2,
    output     [ 6:0] cmdF7,
    output reg [31:0] immI,
    output reg [31:0] immB,
    output reg [31:0] immU 
);
    assign cmdOp = instr[ 6: 0];
    assign rd    = instr[11: 7];
    assign cmdF3 = instr[14:12];
    assign rs1   = instr[19:15];
    assign rs2   = instr[24:20];
    assign cmdF7 = instr[31:25];
```

<!-- Декодер инструкций представляет собой простешую комбинационную схему. Так часть, которая декодирует номера регистров назначения и источника, коды функций и операций выполнена с помощью непрерывных присваиваний. Границы битовых полей взяты из спецификации. Это ровно те поля, которые мы видели в описании команд. -->

---

## Реализация: декодер инструкций (продолжение)

```Verilog
    // I-immediate
    always @ (*) begin
        immI[10: 0] = instr[30:20];
        immI[31:11] = { 21 {instr[31]} };
    end

    // B-immediate
    always @ (*) begin
        immB[    0] = 1'b0;
        immB[ 4: 1] = instr[11:8];
        immB[10: 5] = instr[30:25];
        immB[31:11] = { 21 {instr[31]} };
    end

    // U-immediate
    always @ (*) begin
        immU[11: 0] = 12'b0;
        immU[31:12] = instr[31:12];
    end
endmodule
```

<!-- С декодированием констант код чуть сложнее, но принцип тот же: берем границы полей из спецификации и собираем из них значения констант ровно так, как оно описано в документации. -->

---

## Реализация: регистровый файл

```Verilog
// sr_cpu.v
module sm_register_file
(
    input         clk,
    input  [ 4:0] a0,
    input  [ 4:0] a1,
    input  [ 4:0] a2,
    input  [ 4:0] a3,
    output [31:0] rd0,
    output [31:0] rd1,
    output [31:0] rd2,
    input  [31:0] wd3,
    input         we3
);
    reg [31:0] rf [31:0];

    assign rd0 = (a0 != 0) ? rf [a0] : 32'b0;
    assign rd1 = (a1 != 0) ? rf [a1] : 32'b0;
    assign rd2 = (a2 != 0) ? rf [a2] : 32'b0;

    always @ (posedge clk)
        if(we3) rf [a3] <= wd3;
endmodule
```

<!-- Регистровый файл - это последовательностная схема, представляет собой модуль с массивом регистров. Три порта чтения. Дополнительный порт rd0 добавлен в качестве отладочного, чтобы во время работы процессора у нас была возможность получить значение регистра и вывести его на 7-сегментные индикаторы на отладочной плате.
В соответствии с требованиями архитектуры, которые описаны в спецификации, при чтении из нулевого регистра должен возвращаться ноль. Это реализуется с помощью отдельных тернарных операторов на каждый из портов. 
В текущем виде регистровый файл будет синтезирован в набор регистров, с мультиплексорами на входах и выходах. При проектировании микросхем (ASIC) используют готовые топологические блоки регистровых файлов.
-->

---

## Реализация: операции ALU

```Verilog
// sr_cpu.vh

`define ALU_ADD     3'b000  // A + B

`define ALU_OR      3'b001  // A | B

`define ALU_SRL     3'b010  // A >> B

`define ALU_SLTU    3'b011  // A < B ? 1 : 0

`define ALU_SUB     3'b100  // A - B
```

<!-- Коды операций АЛУ. Никоим образом не завязаны на требования архитектуры. Как и реализация АЛУ это код является следствием решений, принимаемых на уровне микроархитектуры. Если вам потребуется реализовывать поддержку новой операции в АЛУ, то необходимо будет добавить сюда макрос define с новым кодом операции АЛУ -->

---

## Реализация: ALU

```Verilog
// sr_cpu.v
module sr_alu
(
    input  [31:0] srcA,
    input  [31:0] srcB,
    input  [ 2:0] oper,
    output        zero,
    output reg [31:0] result
);
    always @ (*) begin
        case (oper)
            default   : result = srcA + srcB;
            `ALU_ADD  : result = srcA + srcB;
            `ALU_OR   : result = srcA | srcB;
            `ALU_SRL  : result = srcA >> srcB [4:0];
            `ALU_SLTU : result = (srcA < srcB) ? 1 : 0;
            `ALU_SUB : result = srcA - srcB;
        endcase
    end

    assign zero   = (result == 0);
endmodule
```

<!-- Непосредственно реализация самого АЛУ. Это комбинационная схема. Представляет собой набор операций сложения, вычитания, сдвига или сравнения. Подключенных на вход мультиплексора, синтезируемого с помощью конструкции case. Обратите внимание на то, что т.к. результатом синтеза является цифровая схема, то результаты всех операций вычисляются одноврменно. Иными словами: операции oper влияет не на то, какая операция будет вычислена, а на то, какой из результатов мы подключим к выходному порту result.
Пусть вас не смущает серый шрифт на слайде, это ошибка в подсветке кода -->

---

## Реализация: мультиплексоры данных

```Verilog
// sr_cpu.v
wire [31:0] srcB = aluSrc ? immI : rd2;
```

```Verilog
// sr_cpu.v
assign wd3 = wdSrc ? immU : aluResult;
```

<!-- И финальные элементы тракта данных: мулитиплексоры на входе в АЛУ и порт записи регистрового файла. Реализуется с помощью уже знакомых вам тернарных операторов. На этом проектирование и реализацию тракта данных можно считать завершенной. -->

---

## Сигналы управления 1

![h:600 center](png/cu_00.png)

<!-- Перейдем к проектированию устройства управления. Делать это мы будем следующим образом: составим таблицу, в которую столбцами будут значения всех входных и выходных сигналов устройства управления. А строки будут соотвтествовать реализуемым инструкциям. Таким образом для каждой из поддерживаемых команд мы определим свой набор значений управляющих сигналов. -->

---

## Код операции: спецификация

![h:620 center](img/riscv_iset.png)

<!-- Перед тем, как продолжить откроем спецификацию и найдем список кодов операций: значений полей opcode, funct3 и funct7 для каждой из инструкций. Эти коды нужны нам для того, чтобы идентифицировать команды и отличать их друг от друга. Так, например, для команды ADDI, которая приведена в последний сроке таблицы, показанной на слайде, значение opcode = 0010011, а funct3 = 000, при этом funct7 - не используется.
Пожалуйста, найдите эту таблицу в спецификации. -->

---

## Сигналы управления 2

![h:600 center](png/cu_01.png)

<!-- Итак, начнем с ADDI - инструкции сложения регистра и константы. Заполним таблицу только что найденными входными сигналами: opcode = 0010011, а funct3 = 000, при этом funct7 - не используется, и может иметь любое значение -->

---

## Сигналы управления 3

![h:600 center](png/cu_02.png)

<!-- Для инструкции ADDI на вход АЛУ srcB должен быть подана декодированная из инструкции константа immI, поэтому сигнал aluSrc должен быть 1. От АЛУ мы при этом ждем, что в нем будет выполнена операция сложения, поэтому сигнал aluControl должен быть 000 -->

---

## Сигналы управления 4

![h:600 center](png/cu_03.png)

<!-- Результат вычислений должен быть записан в регистровйы файл, для этого выход АЛУ необходимо подключить ко входу WD3, значит сигнал wdSrc = 0. Для того, чтобы по фронту тактового сигнала произошла запись в регистр, устанавливаем regWrite = 1 -->

---

## Сигналы управления 5

![h:600 center](png/cu_04.png)

<!-- Инструкция ADDI не является операцией ветвления, поэтому pcSrc должен быть равен 0, для этого мы устанавливаем branch = 0, сигнал condZero при этом значения не имеет, установим его в 0 -->

---

## Сигналы управления 6

![h:600 center](png/cu_05.png)

<!-- Мы закончили формирование управляющих сигналов для инструкции ADDI. Пожалуйста, пробегитесь еще раз глазами по тому, как скоммутирован тракт данных для ее выполнения и соотнестие это со значениями сигналов на выходе блока управления -->

---

## Сигналы управления 7

![h:600 center](png/cu_06.png)

<!-- Следующей инструкцией, которую мы рассмотрим является ADD - целочисленное регистровое сложение. Из уже знакомой вам таблицы в спецификации выбираем значения кодов функций и операций: cmdOp = 0110011, cmdF3 = 000 и cmdF7 = 000000. Это значения полей инструкции, которые позволяют нам узнать команду ADD среди множества других и они же являются входными сигналами блока управления. -->

---

## Сигналы управления 8

![h:600 center](png/cu_07.png)

<!-- Здесь мы должны выполнить сложение двух операндов, хранящихся в регистрах. для этого вход АЛУ scrB должен быть подключен уже не к константе, immI, как в прошлый раз, а в выходу регистрового файла RD2, поэтому сигнал aluSrc должен быть равен 0. И т.к. это все то же сложение, то aluControl = 000. -->

---

## Сигналы управления 9

![h:600 center](png/cu_08.png)

<!-- Результат вычислений должен быть записан в регистровйы файл, для этого выход АЛУ необходимо подключить ко входу WD3, значит сигнал wdSrc = 0. Для того, чтобы по фронту тактового сигнала произошла запись в регистр, устанавливаем regWrite = 1. Все точно также, как и для предыдущей инструкции -->

---

## Сигналы управления 10

![h:600 center](png/cu_09.png)

<!-- И точно также инструкция ADD не является операцией ветвления, поэтому pcSrc должен быть равен 0, для этого мы устанавливаем branch = 0, сигнал condZero при этом значения не имеет, установим его в 0  -->

---

## Сигналы управления 11

![h:600 center](png/cu_10.png)

<!-- Итак, мы закочнили формирование управляющих сигналов для команды целочисленного сложения ADD. Пожалуйста, пробегите еще раз глазами по тому, каким образом скоммутирован тракт данных и как мы этим управляем. И мы продолжим. -->

---

## Сигналы управления 12

![h:600 center](png/cu_11.png)

<!-- Следующей из рассматриваемых инструкцией будет загрузка константы в регистр. Инструкция LUI - load upper immediate. Она идентифицируется только кодом операции, который равен 0110111, поля cmdF3 и cmdF7 при этом могут иметь любое значение. -->

---

## Сигналы управления 13

![h:600 center](png/cu_12.png)

<!-- Особенность данной инструкции в том, что АЛУ для ее обработки не используется. Все, что нам необходимо сделать, это подать декодированную из инструкции константу immU на вход порта записи регистровго файла, для этого сигнал wdSrc устанавливаем в 1. И разрешить запись в регистровый файл сигналом regWrite = 1. -->

---

## Сигналы управления 14

![h:600 center](png/cu_13.png)

<!-- Сигналы aluSrc и aluConrtol в для этой инструкции могут иметь любое значение, пусть будут нулями. И т.к. это не команда ветвления, то pcSrc=0, branch=0, condZero=0. Здесь все, как и в ранее рассмотренных случаях -->

---

## Сигналы управления 15

![h:600 center](png/cu_14.png)

<!-- Итоговая коммутация тракта данных для обработки команды LUI показана на слайде. Давайте еще раз пробежим по ней глазами и перейдем к более интересным инструкциям ветвления. -->

---

## Сигналы управления 16

![h:600 center](png/cu_15.png)

<!-- Итак, команды условного перехода. Первой из таких инструкций рассмотрим BEQ - branch-on-equal. Ее мы можем идентифицировать по cmdOp=1100011 и cmdF3 = 000. При этом поле cmdF7 может быть любым. Еще раз, значения этих полей мы берем из таблицы в спецификации RISC-V. -->

---

## Сигналы управления 17

![h:600 center](png/cu_16.png)

<!-- Условный переход выполняется в зависимости от результатов сравнения значений, хранящихся в регистрах rs1 и rs2. Значит на вход srcB АЛУ мы должны подключить выход с порта регистрового файла RD2. Для этого устанавливаем aluSrc=0. Для сравнения двух чисем мы будем вычитать одно из другого: подаем на вход aluControl код операции вычитания - это 100. Если операнды равны, то результатом операции будет ноль, и выход aluZero примет значение 1 -->

---

## Сигналы управления 18

![h:600 center](png/cu_17.png)

<!-- Результат данной операции в регистровый файл не записывается, поэтому regWrite = 0, а сигнал wdSrc ни на что не влияет, пусть будет нулем -->

---

## Сигналы управления 19

![h:600 center](png/cu_18.png)

<!-- Для случая, когда операнды равны, и нам необходимо выполнить условный переход, pcSrc должен быть равен 1. При этом сигнал pcBranch окажется подключен ко входу регистра PC. Как при этом формируется значение сигнала pcSrc ? -->

---

## Сигналы управления 20

![h:600 center](png/cu_19.png)

<!-- Значение pcSrc зависит от сигналов aluZero, branch и condZero. Для инструкции BEQ если aluZero = 1, то и pcSrc также должен быть равен 1, т.к. переход выполняется, когда операнды равны. Для этого установим branch = 1 и condZero = 1. Проверим, как работает полученная схема: aluZero = 1 и condZero = 1, значит на выходе схемы сравнения на базе инвертирующего XOR будет 1. Сигнал branch = 1, значит pcSrc = 1, выполняется условный переход. -->

---

## Сигналы управления 21

![h:600 center](png/cu_20.png)

<!-- Теперь рассмотрим работу схемы в случае, когда aluZero = 0. В этом случае на выходе схемы сравнения будет 0, а значит pcSrc будет равен 0. Условный переход не выполняется, следующим значением PC станет pcPlus4 -->

---

## Сигналы управления 22

![h:600 center](png/cu_21.png)

<!-- Рассмотрение команд условного перехода продолжим на примере инструкции BNE - branch-non-equal. Она очень похожа на рассмотренную ранее BEQ, только работает наоборот: условный переход выполняется, когда операнды не равны. Эта инструкция идентифицируется значением cmdOp = 1100011 и cmdF3 = 001. Значение cmdF7 при этом не учитывается.  -->

---

## Сигналы управления 23

![h:600 center](png/cu_22.png)

<!-- Значения сигналов aluSrc, aluControl, wdSrc и regWrite здесь совершенно такие же, как и в случае инструкции BEQ: АЛУ выполняет сравнение путем вычитания операндов, в регистровый файл ничего по итогу не записывается -->

---

## Сигналы управления 24

![h:600 center](png/cu_23.png)

<!-- А вот сигнал pcSrc должен формироваться по-другому: если aluZero = 0, то pcSrc должен быть 1. Для этого установим branch=1, а condZero = 0. Проверим работу условного перехода.
Пусть значения регистров rs1 и rs2 отличаются, тогда результат вычитания одного из другого будет не нулевым, и aluZero=0. Тогда, с учетом того, что condZero=0, на выходе схемы сравнения будет 1. Т.к. branch=1, значит pcSrc=1, и выполняется условный переход: на вход PC подключен сигнал pcBranch -->

---

## Сигналы управления 25

![h:600 center](png/cu_24.png)

<!-- Теперь предположим, что значения в регистрах rs1 и rs2 равны, результатом вычитания одного из другого будет ноль, и aluZero=1. В этом случае на выходе схемы сравнения будет 0. И как результат pcSrc = 0, условный переход не выполняется. На этом описание управляющих сигналов для команды BNE можно считать завершенным.  -->

---

## Сигналы управления 26

![h:600 center](png/cu_25.png)

<!-- Итоговая таблица с сигналами управления процессора schoolRISCV приведена на слайде. Можно сказать, что проектирование блока управления нами успешно завершено и мы можем перейти к его реализации на языке Verilog. -->

---

## Реализация: коды инструкций

```Verilog
// sr_cpu.vh
// instruction opcode
`define RVOP_ADDI   7'b0010011
`define RVOP_BEQ    7'b1100011
...

// instruction funct3
`define RVF3_ADDI   3'b000
`define RVF3_BEQ    3'b000
`define RVF3_BNE    3'b001
`define RVF3_ADD    3'b000
...
`define RVF3_ANY    3'b???

// instruction funct7
`define RVF7_ADD    7'b0000000
...
`define RVF7_ANY    7'b??????? 
```

<!-- И я снова прошу вас открыть исходный код процессора schoolRISCV в браузере на гитхабе или в текстовом редакторе. Это упростит вашу дальнейшую работу.
Константы со значениями полей кодов операции и функции мы задаем в виде макросов, они описаны в заголовочном файле sr_cpu.vh их значения взяты из спецификации RISC-V из уже знакомой вам таблицы.
Обратите внимание на макросы RVF3_ANY и RVF7_ANY. Их значения заданы вопросительными знаками, и в дальнейшем они используются внутри языковой конструкции casez - это оператор case, умеющий работать со значениями, часть из которых составляют не значащие биты, которые могут принимать любое значение. Их использование вы увидите позже -->

---

## Реализация: устройство управления (начало)

```Verilog
// sr_cpu.v
module sr_control
(
    input     [ 6:0] cmdOp,
    input     [ 2:0] cmdF3,
    input     [ 6:0] cmdF7,
    input            aluZero,
    output           pcSrc, 
    output reg       regWrite, 
    output reg       aluSrc,
    output reg       wdSrc,
    output reg [2:0] aluControl
);
    reg          branch;
    reg          condZero;
    assign pcSrc = branch & (aluZero == condZero);
```

<!-- само устрйоство управления представляет собой комбинационную схему. Порты этого модуля вам уже знакомы, это столбцы из таблицы, которую мы недавно заполняли.
Значение pcSrc задается с помощью непрерываного присваивания. И логика его вычисления вам уже знакома. -->

---

## Реализация: устройство управления (продолжение)

```Verilog
// sr_cpu.v
    always @ (*) begin
        branch      = 1'b0;
        condZero    = 1'b0;
        regWrite    = 1'b0;
        aluSrc      = 1'b0;
        wdSrc       = 1'b0;
        aluControl  = `ALU_ADD;

        casez( {cmdF7, cmdF3, cmdOp} )
            { `RVF7_ADD,  `RVF3_ADD,  `RVOP_ADD  } : begin regWrite = 1'b1; aluControl = `ALU_ADD;  end
            { `RVF7_OR,   `RVF3_OR,   `RVOP_OR   } : begin regWrite = 1'b1; aluControl = `ALU_OR;   end
            { `RVF7_SRL,  `RVF3_SRL,  `RVOP_SRL  } : begin regWrite = 1'b1; aluControl = `ALU_SRL;  end
            { `RVF7_SLTU, `RVF3_SLTU, `RVOP_SLTU } : begin regWrite = 1'b1; aluControl = `ALU_SLTU; end
            { `RVF7_SUB,  `RVF3_SUB,  `RVOP_SUB  } : begin regWrite = 1'b1; aluControl = `ALU_SUB;  end

            { `RVF7_ANY,  `RVF3_ADDI, `RVOP_ADDI } : begin regWrite = 1'b1; aluSrc = 1'b1; aluControl = `ALU_ADD; end
            { `RVF7_ANY,  `RVF3_ANY,  `RVOP_LUI  } : begin regWrite = 1'b1; wdSrc  = 1'b1; end

            { `RVF7_ANY,  `RVF3_BEQ,  `RVOP_BEQ  } : begin branch = 1'b1; condZero = 1'b1; aluControl = `ALU_SUB; end
            { `RVF7_ANY,  `RVF3_BNE,  `RVOP_BNE  } : begin branch = 1'b1; aluControl = `ALU_SUB; end
        endcase
    end
```

<!-- Основная часть логики устройства управления построена с использованием блокирующих присваиваний и конструкции casez. В зависимости от сочетания сигналов cmdF7, cmdF3 и cmdOp устанавливаются те или иные значения выходных сигналов. 
На этом мы завершаем рассмотрение реализации устройства управления. -->

---

## Структура проекта и подключение периферии

![h:600 center](img/board.png)

<!-- Перед тем, как мы перейдем к практической части работы с schoolRISCV, рассмотрим, каким образом процессорное ядро подключается к периферии при синтезе и запуске на отладочной плате с ПЛИС. Данный слайд сформирован на примере платы DE10-Lite, для остальных плат подключение организовано похожим образом.
Само процессорное ядро, исходный код которого мы детально разобрали выше - это модуль sr_cpu. И его файлы лежат в калоге src проекта. Модуль sm_top содержит код специфический для каждои из отладочных плат. Этот код можно найти в подкаталогах папки board. Например исходный код, специфический для платы de10_lite находится в каталоге boards/de10_lite.
В составе модуля sm_top есть блок делителя частоты sm_clk_divider, который позволяет снизить частоту до нескольих Гц или еще ниже, для того, чтобы можно было отслеживать работу процессора на каждом такте. Настройки делителя частоты задаются выведенными на кнопки сигналами clkEnable и clkDivide. Первый разрешает или запрещает тактирование, т.е. с помощью него мы можем приостановить работу процессора на некоторое время и посмотреть, какие значение хранятся в том или ином регистре. А с помощью  сигнала clkDivide мы задаем настройки делителя частоты, т.е. определяем, насколько быстро будет работать наш процессор.
С помощью переключателей regAddr мы можем выбрать номер регистра, данные внутри которого будут выведены на 7-сегментный индикатор. Мы с вами помним, что согласно требованиям архитектуры RISC-V при чтении из нулевого регистра всегда возвращается ноль. Поэтому вместо того ,чтобы считывать нулевой регистр, когда переключатели regAddr установлены в ноль, мы будем считывать значение PC.
Из не упомянутого, еще есть кнопка ресет, которая позволяет выполнить сброс регистров процессора в начальное состояние, что приводит к тому, что программа начинает выполняться с нулевого адреса. -->

---

## Программирование системы

![h:600 center](png/program_flow.png)

<!-- Теперь, что касается программирования системы, или процесса прошивки - т.е. тех действий, благодаря которым программа попадает в память программ.
Здесь у нас есть 2 варианта. В первом случае программа на ассеблере превращается в 16-ричный текстовый дамп с помощью уже знакомого вам симулятора RARS, он умеет это делать - т.е. сохранять дамп памяти программ в виде текстового файла. 
Этот текстовый файл, который называется program.hex упомянут в качестве аргурмента функции readmemh, поэтому он обрабатывается инструментами синтеза и служит для инициализации памяти программ уже на сборки bitstream с помощью квартуса. Дальше вы прошиваете ПЛИС и программа попадает в память вместе с прошивкой.
Есть и более "взрослый" путь сборки программы, когда вместо симулятора RARS мы используем RISC-V toolchain - т.е. ровно тот же самый компилятор, который используется программистами при разработке под RISC-V платформы. В этом случае мы компилируем программу с помощью gcc, получаем исполняемый файл в формате elf - это как exe, только для linux-систем. И извлекаем из него дамп секции с кодом программы с помощью утилиты objcopy.
Оба этих маршрута мы пройдем в ходе практики.
 -->

---

## Что дальше?

- Цифровая схемотехника и архитектура компьютера
David Harris & Sarah Harris
ДМК Пресс

- Цифровой синтез: практический курс
Александр Романов & Юрий Панчул
ДМК Пресс

- Syntacore SCR1
https://github.com/syntacore/scr1

- Learning RISC-V
https://riscv.org/community/learn-about-risc-v/

<!-- Итак, впереди нас ждет практическая часть. А сейчас я немного сориентирую вас о том, что еще вы можете почитать на эту тему.
Что касается материалов на русском языке, это знаменитая книга Харрисов - если вы еще не ознакомились с ней, то настойчиво рекомендую это сделать. Плюс книга "Цифровой синтез: практический курс". Также вы можете присмотреться к ядру SCR1, это опенсорсное процессорное ядро, написанное на  verilog компанией из Санкт-Петербурка под названием Syntacore. Это небольшое ядро, уровня микроконтроллеров, но оно уже в разы сложнее чем schoolRISCV.
Кроме того, на сайте RISC-V есть раздел с обучающими материалами, он постоянно пополняется и там тоже можно что-то найти. 
-->

---

## Ваши вопросы?

<!-- На этом все. Благодарю за внимание -->
